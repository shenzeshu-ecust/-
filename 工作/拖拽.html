<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        #con {
            width: 300px;
            height: 350px;
            border: 1px solid salmon;
            margin: 100px auto;
        }

        .ele {
            width: 200px;
            height: 50px;
            background-color: cadetblue;
            border-radius: 5px;
            color: #fff;
            line-height: 50px;
            margin: 10px auto 10px auto;

            text-align: center;
        }
    </style>
</head>

<body>
    <ul id="con">
        <li class="ele" draggable="true">第一名</li>
        <li class="ele" draggable="true">第二名</li>
        <li class="ele" draggable="true">第三名</li>
        <li class="ele" draggable="true">第四名</li>
        <li class="ele" draggable="true">第五名</li>
    </ul>
    <script>
        let node = document.querySelector('#con')
        let dragging = null
        // 用了事件委托！ li 委托给ul
        node.ondragstart = function (e) {
            // setData()第一个参数不能写"text", 因为firefox会打开新标签页
            e.dataTransfer.setData('te', e.target.innerText)
            dragging = e.target
        }

        // onDragover事件规定了 在何处放置被拖动的数据
        // 他默认无法将元素、数据放置到其他 元素中的
        node.ondragover = function (e) {
            e.preventDefault(); // 使其能 将数据 元素放置到其他元素里
            let target = e.target
            if (target.nodeName === 'LI') {
                if (target !== dragging) {
                    let targetRect = target.getBoundingClientRect()
                    let draggingRect = dragging.getBoundingClientRect()
                    if (target) {
                        if (target.animated) {
                            return
                        }
                    }
                    if (getIndex(dragging) < getIndex(target)) {
                        target.parentNode.insertBefore(dragging, target)
                    }
                    _animate(draggingRect, dragging)
                    _animate(targetRect, target)

                }
            }
        }

        function getIndex(el) {
            let index = 0
            if (!el || !el.parentNode) return -1
            while (el && (el = el.previousElementSibling)) {
                index++
            }
            return index
        }

        function _animate(prevRect, target) {
            let ms = 300
            if (ms) {
                let currentRect = target.getBoundingClientRect()

                if (prevRect.nodeType === 1) {
                    prevRect = prevRect.getBoundingClientRect()
                }
                styleEvent(target, 'transition', 'none')
                styleEvent(target, 'transform', 'translate3d(' + (prevRect.left - currentRect.left) + 'px,' + (prevRect.top - currentRect.top) + 'px, 0)')
                // 触发重绘
                target.offsetWidth;
                styleEvent(target, 'transition', 'all ' + ms + 'ms')
                styleEvent(target, 'transform', 'translate3d(0, 0, 0)')

                clearTimeout(target.animated)
                target.animated = setTimeout(function () {
                    styleEvent(target, 'transition', '')
                    styleEvent(target, 'transform', '')
                    target.animated = false

                }, ms)

            }
        }

        function styleEvent(el, prop, val) {
            let style = el && el.style
            if (style) {
                if (val === void 0) {
                    if (document.defaultView && document.defaultView.getComputedStyle) {
                        val = document.defaultView.getComputedStyle(el, '')
                    } else {
                        val = el.currentStyle
                    }
                    return prop === void 0 ? val : val[prop]
                } else {
                    if (!(prop in style)) {
                        prop = "-webkit-" + prop
                    }
                    style[prop] = val + (typeof val === 'string' ? '' : 'px')
                }
            }
        }
    </script>
</body>

</html>