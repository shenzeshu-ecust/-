// ! 可达性 reachability
/*
    * JavaScript 中主要的内存管理概念是 可达性。

    简而言之，“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。

        这里列出固有的可达值的基本集合，这些值明显不能被释放。

        比方说：
            当前执行的函数，它的局部变量和参数。
            当前嵌套调用链上的其他函数、它们的局部变量和参数。
            全局变量。
            （还有一些内部的）

        ~ 这些值被称作 根（roots）。

        ~ 如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的。

        比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则 该 对象被认为是可达的。而且它引用的内容也是可达的。

    在 JavaScript 引擎中有一个被称作 垃圾回收器 的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。

*/

// 两个引用
// user 具有对这个对象的引用
let user = {
    name: "John"
  };
  
let admin = user; // 两个指针指向同一个对象
// ~ 如果执行user = null
user = null // ! 注意： user只是一个地址，不是存储它的地方，所以置为null只是 取消了一个指针 ~
console.log(admin) // * { name: 'John' }
// ! 对象仍然可以被通过 admin 这个全局变量访问到，因此它必须被保留在内存中。如果我们又重写了 admin，对象就会被删除。


// ! 垃圾回收算法
/*
    垃圾回收的基本算法被称为 “mark-and-sweep”。 
  ~ 标记清除法
    定期执行以下“垃圾回收”步骤：

        垃圾收集器找到所有的根，并“标记”（记住）它们。
        然后它遍历并“标记”来自它们的所有引用。
        然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。
        ……如此操作，直到所有可达的（从根部）引用都被访问到。
        没有被标记的对象都会被删除。

    这是垃圾收集工作的概念。JavaScript 引擎做了许多优化，使垃圾回收运行速度更快，并且不会对代码执行引入任何延迟。

一些优化建议：

    分代收集（Generational collection）—— 对象被分成两组：“新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现、完成它们的工作并很快死去，因此在这种情况下跟踪 新对象 并将其从内存中清除是有意义的。
            那些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。
    增量收集（Incremental collection）—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。
            因此，引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。这样就会有很多小型的垃圾收集，而不是一个大型的。
            这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。
    闲时收集（Idle-time collection）—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。

还有其他垃圾回收算法的优化和风格。尽管我想在这里描述它们，但我必须打住了，因为不同的引擎会有不同的调整和技巧。而且，更重要的是，随着引擎的发展，情况会发生变化，所以在没有真实需求的时候，“提前”学习这些内容是不值得的。当然，除非你纯粹是出于兴趣。
*/

/*
    * 总结
   ~ 1 垃圾回收是自动完成的，我们不能强制执行或是阻止执行。
   ~ 2 当对象是可达状态时，它一定是存在于内存中的。
   ~ 3 被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达，
*/


// 一个有趣的例子
function marry(man, woman) {
    woman.husband = man;
    man.wife = woman;
  
    return {
      father: man,
      mother: woman
    }
  }
  
let family = marry({
  name: "John"
}, {
  name: "Ann"
});

// 目前为止 所有对象都可达
// 现在想要删除 关于John的引用
delete family.father;
delete family.mother.husband;

// * 仅删除这两个引用中的一个是不够的，因为所有的对象仍然都是可达的。