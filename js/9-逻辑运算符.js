// 1 或 ||
const value1 = 0;
const value2 = undefined;
const value3 = 1;

const result = value1 || value2 || value3;
/*
    或运算符 || 做了如下的事情：

    1 从左到右依次计算操作数。
    2 处理每一个操作数时，都将其转化为布尔值。如果结果是 true，就停止计算，返回这个操作数的初始值。
  ! 3 如果所有的操作数都被计算过（也就是，转换结果都是 false），则  返回最后一个操作数!
*/
console.log(null || 1); // 1
console.log(null || 0 || 1); // 1
console.log(null || undefined || 0); // * 0 因为都是falsy 所以返回最后一个值

// 2 与 &&
const result2 = value1 && value2 && value3;
/*
    与运算 && 做了如下的事：

    1 从左到右依次计算操作数。
    2 在处理每一个操作数时，都将其转化为布尔值。如果结果是 false，就停止计算，并返回这个操作数的初始值。
  ! 3 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。

    ! 换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值。
*/

// * 区别就是与运算返回第一个假值，而或运算返回第一个真值。

console.log(1 && 0); // 0
console.log(1 && 5); // 5
console.log(null && 5); // null
console.log(0 && "no matter what"); // 0 遇到假值  直接返回
console.log(1 && 2 && 3); // 3 都是真值  返回最后一个

// ! 3 与运算 && 的优先级比或运算 || 要高
// 代码 a && b || c && d 跟 && 表达式加了括号完全一样：(a && b) || (c && d)。

// 4 非 ！

// ~ 5 两个非运算 !! 有时候用来将某个值转化为布尔类型：
console.log(!!"non-empty string"); // true
console.log(!!null); // false
// 也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。最后我们就得到了一个任意值到布尔值的转化。
// !!(x) 等效于 Boolean(x)

// ~ 非运算符 ! 的优先级在所有逻辑运算符里面最高，所以它总是在 && 和 || 之前执行。

// test
// 下面的代码将会输出什么？
alert(alert(1) || 2 || alert(3));
// 首先是1 然后是2
/*
 * 对 alert 的调用没有返回值。或者说返回的是 undefined。

    第一个或运算 || 对它的左值 alert(1) 进行了计算。这就显示了第一条信息 1。
    函数 alert 返回了 undefined，所以或运算继续检查第二个操作数以寻找真值。
    第二个操作数 2 是真值，所以执行就中断了。2 被返回，并且被外层的 alert 显示。

    这里不会显示 3，因为运算没有抵达 alert(3)。
 */
alert(alert(1) && alert(2));
// 1，然后 undefined。
/*
    * 调用 alert 返回了 undefined（它只展示消息，所以没有有意义的返回值）。

    因此，&& 计算了它左边的操作数（显示 1），然后立即停止了，因为 undefined 是一个假值。&& 就是寻找假值然后返回它，所以运算结束。
*/
