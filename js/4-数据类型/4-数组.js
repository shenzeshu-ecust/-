// ~ 数组： 能存储有序的集合， 可以插入，排列等
// 里面可以存储任何类型的元素
// ! 1 创建数组  两种：
let arr = [];
let arr1 = new Array();

// ! 2 arr.at()  支持负数访问数组元素
// 假如想访问最后一个元素 arr[-1]不行🚫
let fruits = ["Apple", "Orange", "Plum"];
console.log(fruits[fruits.length - 1]); // Plum
console.log(fruits.at(-1)); // ~ Plum

// ! 3 添加
// 两者一样
fruits.push("Banana");
fruits[fruits.length] = "Pineapple";

// ~ unshift 和 push 可以一次添加多个元素
fruits.push("Orange", "Peach");
fruits.unshift("Pineapple", "Lemon");

/**
 * 数组真正特殊的是它们的内部实现。JavaScript 引擎尝试把这些元素一个接一个地存储在连续的内存区域，就像本章的插图显示的一样，而且还有一些其它的优化，以使数组运行得非常快。
 * 但是，如果我们不像“有序集合”那样使用数组，而是像常规对象那样使用数组，这些就都不生效了。
 * 例如，从技术上讲，我们可以这样做:
let fruits = []; // 创建一个数组

fruits[99999] = 5; // 分配索引远大于数组长度的属性

fruits.age = 25; // 创建一个具有任意名称的属性

这是可以的，因为数组是基于对象的。我们可以给它们添加任何属性。
但是 Javascript 引擎会发现，我们在像使用常规对象一样使用数组，那么针对数组的优化就不再适用了，然后对应的优化就会被关闭，这些优化所带来的优势也就荡然无存了。

 */

/*

~ 数组误用的几种方式:

    ~ 1添加一个非数字的属性，比如 arr.test = 5。
    ~ 2 制造空洞，比如：添加 arr[0]，然后添加 arr[1000] (它们中间什么都没有)。
    ~ 3 以倒序填充数组，比如 arr[1000]，arr[999] 等等。

*/

// ! 4 性能
// ~ push/pop 方法运行的比较快，而 shift/unshift 比较慢。

// 为什么作用于数组的末端会比首端快呢？让我们看看在执行期间都发生了什么：
fruits.shift(); // 从首端取出一个元素
/*
 * 只获取并移除索引 0 对应的元素是不够的。其它元素也需要被重新编号。

shift 操作必须做三件事:

    1 移除索引为 0 的元素。
    2 把所有的元素向左移动，把索引 1 改成 0，2 改成 1 以此类推，对其重新编号。
    3 更新 length 属性。
~ 数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作。
unshift 也是一样：为了在数组的首端添加元素，我们首先需要将现有的元素向右移动，增加它们的索引值。

* 那 push/pop 是什么样的呢？它们不需要移动任何东西。如果从末端移除一个元素，pop 方法只需要清理索引值并缩短 length 就可以了。
* pop 方法不需要移动任何东西，因为其它元素都保留了各自的索引。这就是为什么 pop 会特别快。
 */

// ! 5 循环
// 1）最古老的 for i ++ ... 运行得最快，可兼容旧版本浏览器！
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
// 2) for of 不能获取当前元素的索引，只是获取元素值
for (let fruit of fruits) {
  console.log(fruit);
}

// ? 3) for in 技术上来讲，因为数组也是对象，所以使用 for..in 也是可以的：
for (let key in fruits) {
  console.log(fruits[key]); // Apple, Orange, Pear
}
/*
? 但这其实是一个很不好的想法。会有一些潜在问题存在：

~ 1 for..in 循环会遍历 所有属性，不仅仅是这些数字属性。

    在浏览器和其它环境中有一种称为“类数组”的对象，它们 看似是数组。
    也就是说，它们有 length 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。
    for..in 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。

   ~ 2 for..in 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。

~ 通常来说，我们不应该用 for..in 来处理数组。
*/

// ! 6 数组的length属性：当我们修改数组的时候，length 属性会自动更新。准确来说，它实际上不是数组里元素的个数，而是【最大的数字索引值加一】。
// 例如，一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 length 也会很大
let arr2 = [];
arr2[123] = "A";
console.log(arr2.length); // ~ 124 !

// ~ length 属性的另一个有意思的点是它是可写的。
// ~ 如果我们手动增加它，则不会发生任何有趣的事儿。但是如果我们减少它，数组就会被截断。该过程是不可逆的，
arr = [1, 2, 3, 4, 5];
arr.length = 2;
console.log(arr); // [ 1, 2 ]
arr.length = 5;
console.log(arr); // [ 1, 2, <3 empty items> ]
console.log(arr[3]); //  undefined : 被截断的那些数值并没有回来
// ~ 所以，清空数组最简单的方法就是：arr.length = 0;

// ! 7 new Array() 的 问题
// 用法
let arr3 = new Array(1, 3, 5);
// ~ 问题： 如果使用单个参数（即数字）调用 new Array，那么它会创建一个 指定了长度，却没有任何项 的数组。
let arr4 = new Array(2);
console.log(arr4[0]); // undefined
console.log(arr4.length); // 2
// 为了避免这种意外情况，我们通常使用方括号，除非我们真的知道自己在做什么。

// ! 8 数组有自己的 toString 方法的实现，会返回以逗号隔开的元素列表。
let arr5 = [1, 2, 3];
console.log(arr5.toString()); // 1, 2, 3

console.log([] + 1); // "1"
console.log([1] + 1); // "11"
console.log([1, 2] + 1); // "1,21"
// ~ 数组没有 Symbol.toPrimitive，也没有 valueOf，它们只能执行 toString 进行转换，所以这里 [] 就变成了一个空字符串，[1] 变成了 "1"，[1,2] 变成了 "1,2"。
// ~ 当 "+" 运算符把一些项加到字符串后面时，加号后面的项也会被转换成字符串

// ! 9 不要用 == 比较数组
/**
 * 回顾 == 比较规则
    1 仅当两个对象引用的是同一个对象时，它们才相等 ==。
    2 如果 == 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型，转换规则如 对象 —— 原始值转换 一章所述。
    3 ……null 和 undefined 相等 ==，且各自不等于任何其他的值。
 * 严格比较 === 更简单，因为它不会进行类型转换。
 */
// ~ 所以，如果我们使用 == 来比较数组，除非我们比较的是两个引用同一数组的变量，否则它们永远不相等。
console.log([] == []); // false
console.log([0] == [0]); // false 从技术上讲，这些数组是不同的对象。所以它们不相等。== 运算符不会进行逐项比较

// 与原始类型的比较也可能会产生看似很奇怪的结果：
console.log(0 == []); // true 数组 [] 被转换为原始类型以进行比较，被转换成了一个空字符串 ''。  '' 被转换成了数字 0
console.log("0" == []); // false    '' != '0'

// ? TEST
let arr6 = ["a", "b"];
arr6.push(function () {
  console.log(this);
});
arr6[2](); // [ 'a', 'b', [Function (anonymous)] ]
